const IS_TOUCH = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

class SolitaireGame {
    constructor() {
        this.stock = [];
        this.waste = [];
        this.tableau = Array.from({ length: 7 }, () => []);
        this.foundations = Array.from({ length: 4 }, () => []);

        this.draggedCards = null;
        this.dragSource = null;

        // Mobile / auto-complete state
        this.longPressTimer = null;
        this.touchDragging = false;
        this.autoCompleteTimer = null;

        this.initGame();
    }

    /* ===================== AUTO MOVE ===================== */
    autoMoveCard(card, sourceType, sourceIndex) {
        for (let i = 0; i < 4; i++) {
            if (this.canPlaceOnFoundation(card, i)) {
                this.moveCards([card], sourceType, sourceIndex, 'foundation', i);
                return true;
            }
        }

        for (let i = 0; i < 7; i++) {
            if (this.canPlaceOnTableau(card, i)) {
                this.moveCards([card], sourceType, sourceIndex, 'tableau', i);
                return true;
            }
        }
        return false;
    }

    /* ===================== AUTO COMPLETE ===================== */
    canAutoComplete() {
        if (this.stock.length || this.waste.length) return false;
        return this.tableau.every(p => p.every(c => c.faceUp));
    }

    startAutoComplete() {
        if (!this.canAutoComplete() || this.autoCompleteTimer) return;

        this.autoCompleteTimer = setInterval(() => {
            let moved = false;

            for (let t = 0; t < 7 && !moved; t++) {
                const pile = this.tableau[t];
                if (!pile.length) continue;

                const card = pile[pile.length - 1];
                for (let f = 0; f < 4; f++) {
                    if (this.canPlaceOnFoundation(card, f)) {
                        this.moveCards([card], 'tableau', t, 'foundation', f);
                        moved = true;
                        break;
                    }
                }
            }

            if (!moved) {
                clearInterval(this.autoCompleteTimer);
                this.autoCompleteTimer = null;
            }

            this.render();
            this.updateStats();
        }, 250);
    }

    /* ===================== CARD INTERACTION ===================== */
    addCardInteraction(cardEl, card, sourceType, sourceIndex) {

        // ---------- DESKTOP ----------
        if (!IS_TOUCH) {
            cardEl.draggable = true;

            cardEl.addEventListener('dragstart', () => {
                const idx = Number(cardEl.dataset.cardIndex) || 0;
                this.draggedCards =
                    sourceType === 'tableau'
                        ? this.tableau[sourceIndex].slice(idx)
                        : [card];
                this.dragSource = { type: sourceType, index: sourceIndex };
                cardEl.classList.add('dragging');
            });

            cardEl.addEventListener('dragend', () => {
                cardEl.classList.remove('dragging');
                this.draggedCards = null;
                this.dragSource = null;
            });

            cardEl.addEventListener('dblclick', () => {
                if (this.autoMoveCard(card, sourceType, sourceIndex)) {
                    this.render();
                    this.updateStats();
                    this.startAutoComplete();
                }
            });
            return;
        }

        // ---------- MOBILE ----------
        cardEl.addEventListener('click', (e) => {
            e.stopPropagation();
            if (this.autoMoveCard(card, sourceType, sourceIndex)) {
                this.render();
                this.updateStats();
                this.startAutoComplete();
            }
        });

        cardEl.addEventListener('touchstart', (e) => {
            e.preventDefault();

            const idx = Number(cardEl.dataset.cardIndex) || 0;
            const touch = e.touches[0];
            const startX = touch.clientX;
            const startY = touch.clientY;

            this.longPressTimer = setTimeout(() => {
                this.touchDragging = true;
                this.draggedCards =
                    sourceType === 'tableau'
                        ? this.tableau[sourceIndex].slice(idx)
                        : [card];
                this.dragSource = { type: sourceType, index: sourceIndex };
                cardEl.classList.add('dragging');
            }, 350);

            const move = (me) => {
                if (!this.touchDragging) return;
                const t = me.touches[0];
                cardEl.style.transform =
                    `translate(${t.clientX - startX}px, ${t.clientY - startY}px) scale(1.05)`;
                cardEl.style.zIndex = 999;
            };

            const end = () => {
                clearTimeout(this.longPressTimer);
                cardEl.style.transform = '';
                cardEl.style.zIndex = '';
                cardEl.classList.remove('dragging');
                this.touchDragging = false;
                this.draggedCards = null;
                this.dragSource = null;
                document.removeEventListener('touchmove', move);
                document.removeEventListener('touchend', end);
            };

            document.addEventListener('touchmove', move);
            document.addEventListener('touchend', end);
        });
    }

    /* ===================== DROP ZONES ===================== */
    addDropZone(el, destType, destIndex) {
        const attemptDrop = () => {
            if (!this.draggedCards || !this.dragSource) return;

            const card = this.draggedCards[0];
            let valid = false;

            if (destType === 'foundation' && this.draggedCards.length === 1) {
                valid = this.canPlaceOnFoundation(card, destIndex);
            } else if (destType === 'tableau') {
                valid = this.tableau[destIndex].length === 0
