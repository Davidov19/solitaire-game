<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Solitaire + Undo</title>
    <style>
        :root {
            --green: #1a5e20;
            --card-w: 80px;
            --card-h: 112px;
        }
        body {
            background-color: var(--green);
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            overflow-x: hidden;
            color: white;
            user-select: none;
        }
        #hud {
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .controls { display: flex; gap: 10px; }
        .btn {
            background: #ffffff;
            color: #1a5e20;
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        .btn:hover { background: #e0e0e0; }
        .btn:disabled { background: #888; color: #ccc; cursor: not-allowed; }

        #game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 30px;
            gap: 25px;
        }
        .row { display: flex; gap: 12px; justify-content: center; width: 100%; }
        
        .pile {
            width: var(--card-w);
            height: var(--card-h);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            position: relative;
            background: rgba(0,0,0,0.05);
        }
        
        .card {
            width: var(--card-w);
            height: var(--card-h);
            background: white;
            border-radius: 6px;
            position: absolute;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.4);
            color: black;
            padding: 6px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            border: 1px solid #ccc;
        }
        .card.back {
            background: #2b5797;
            background-image: repeating-linear-gradient(135deg, #2b5797, #2b5797 6px, #3b67a7 6px, #3b67a7 12px);
            border: 2px solid white;
        }
        .card.red { color: #d32f2f; }
        .suit-center {
            font-size: 2.2rem;
            text-align: center;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1000; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="controls">
            <button class="btn" onclick="game.initGame()">New Game</button>
            <button class="btn" id="undoBtn" onclick="game.undo()">Undo</button>
        </div>
        <div>Score: <span id="score">0</span></div>
        <div>Time: <span id="timer">0:00</span></div>
        <button class="btn" onclick="location.reload()">Restart</button>
    </div>

    <div id="game-board">
        <div class="row">
            <div id="stock" class="pile"></div>
            <div id="waste" class="pile"></div>
            <div style="width: 40px;"></div>
            <div class="pile foundation" data-idx="0"></div>
            <div class="pile foundation" data-idx="1"></div>
            <div class="pile foundation" data-idx="2"></div>
            <div class="pile foundation" data-idx="3"></div>
        </div>
        <div class="row">
            <div class="pile tableau" data-idx="0"></div>
            <div class="pile tableau" data-idx="1"></div>
            <div class="pile tableau" data-idx="2"></div>
            <div class="pile tableau" data-idx="3"></div>
            <div class="pile tableau" data-idx="4"></div>
            <div class="pile tableau" data-idx="5"></div>
            <div class="pile tableau" data-idx="6"></div>
        </div>
    </div>

    <canvas id="victory-canvas"></canvas>

<script>
const SUITS = ['♠', '♣', '♥', '♦'];
const VALS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

class Solitaire {
    constructor() {
        this.history = [];
        this.canvas = document.getElementById('victory-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.initGame();
    }

    saveState() {
        const state = JSON.stringify({
            stock: this.stock,
            waste: this.waste,
            foundations: this.foundations,
            tableau: this.tableau,
            score: this.score
        });
        this.history.push(state);
        document.getElementById('undoBtn').disabled = false;
    }

    undo() {
        if (this.history.length === 0) return;
        const state = JSON.parse(this.history.pop());
        this.stock = state.stock;
        this.waste = state.waste;
        this.foundations = state.foundations;
        this.tableau = state.tableau;
        this.score = Math.max(0, state.score - 2); // Small penalty for undoing
        this.render();
        if (this.history.length === 0) document.getElementById('undoBtn').disabled = true;
    }

    initGame() {
        this.history = [];
        document.getElementById('undoBtn').disabled = true;
        this.score = 0;
        this.seconds = 0;
        
        let deck = [];
        SUITS.forEach(s => VALS.forEach((v, i) => {
            deck.push({ suit: s, val: v, rank: i+1, color: (s==='♥'||s==='♦')?'red':'black', faceUp: false });
        }));
        deck.sort(() => Math.random() - 0.5);

        this.foundations = [[],[],[],[]];
        this.tableau = [[],[],[],[],[],[],[]];
        for(let i=0; i<7; i++) {
            for(let j=i; j<7; j++) {
                let card = deck.pop();
                if(i === j) card.faceUp = true;
                this.tableau[j].push(card);
            }
        }
        this.stock = deck;
        this.waste = [];
        this.render();
        
        if(this.timer) clearInterval(this.timer);
        this.timer = setInterval(() => {
            this.seconds++;
            let m = Math.floor(this.seconds/60);
            let s = (this.seconds%60).toString().padStart(2,'0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);
    }

    render() {
        document.getElementById('score').innerText = this.score;
        this.drawPile('#stock', this.stock, 'stock');
        this.drawPile('#waste', this.waste, 'waste');
        this.foundations.forEach((f, i) => this.drawPile(`.foundation[data-idx="${i}"]`, f, 'foundation', i));
        this.tableau.forEach((t, i) => this.drawPile(`.tableau[data-idx="${i}"]`, t, 'tableau', i));
    }

    drawPile(sel, cards, type, pIdx) {
        const el = document.querySelector(sel);
        el.innerHTML = '';
        cards.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = `card ${c.faceUp ? c.color : 'back'}`;
            if(c.faceUp) {
                div.innerHTML = `<div>${c.val}${c.suit}</div><div class="suit-center">${c.suit}</div>`;
                div.draggable = true;
                div.ondragstart = () => {
                    this.dragging = type === 'tableau' ? cards.slice(i) : [c];
                    this.source = { type, pIdx };
                };
                div.ondblclick = (e) => {
                    e.stopPropagation();
                    this.autoMove(c, type, pIdx);
                };
            }
            if(type === 'tableau') div.style.top = `${i * 20}px`;
            el.appendChild(div);
        });
        el.ondragover = e => e.preventDefault();
        el.ondrop = () => this.handleDrop(type, pIdx);
    }

    handleDrop(type, pIdx) {
        if(!this.dragging) return;
        const c = this.dragging[0];
        let ok = false;

        if(type === 'foundation' && this.dragging.length === 1) {
            const f = this.foundations[pIdx];
            ok = f.length === 0 ? c.rank === 1 : (c.suit === f[f.length-1].suit && c.rank === f[f.length-1].rank + 1);
        } else if(type === 'tableau') {
            const t = this.tableau[pIdx];
            ok = t.length === 0 ? c.rank === 13 : (c.color !== t[t.length-1].color && c.rank === t[t.length-1].rank - 1);
        }

        if(ok) {
            this.saveState();
            const src = this.source.type === 'tableau' ? this.tableau[this.source.pIdx] : this.waste;
            const moved = src.splice(src.length - this.dragging.length);
            (type === 'tableau' ? this.tableau[pIdx] : this.foundations[pIdx]).push(...moved);
            
            if(src.length > 0 && !src[src.length-1].faceUp) {
                src[src.length-1].faceUp = true;
                this.score += 5;
            }
            this.score += (type === 'foundation' ? 10 : 5);
            this.render();
            this.checkWin();
        }
        this.dragging = null;
    }

    autoMove(c, type, pIdx) {
        for(let i=0; i<4; i++) {
            const f = this.foundations[i];
            if((f.length===0 && c.rank===1) || (f.length>0 && c.suit===f[f.length-1].suit && c.rank===f[f.length-1].rank+1)) {
                this.dragging = [c]; this.source = {type, pIdx};
                this.handleDrop('foundation', i);
                return;
            }
        }
    }

    checkWin() {
        if(this.foundations.every(f => f.length === 13)) this.winAnim();
    }

    winAnim() {
        this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight;
        let cards = [];
        this.foundations.flat().forEach(c => cards.push({...c, x: Math.random()*this.canvas.width, y: 100, vx: (Math.random()-0.5)*15, vy: 2}));
        const loop = () => {
            this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
            cards.forEach(c => {
                c.x += c.vx; c.y += c.vy; c.vy += 0.5;
                if(c.y > this.canvas.height-112) { c.y = this.canvas.height-112; c.vy *= -0.85; }
                if(c.x < 0 || c.x > this.canvas.width-80) c.vx *= -1;
                this.ctx.fillStyle = "white"; this.ctx.fillRect(c.x, c.y, 80, 112);
                this.ctx.fillStyle = c.color; this.ctx.font = "16px Arial"; this.ctx.fillText(c.val + c.suit, c.x+5, c.y+20);
            });
            requestAnimationFrame(loop);
        };
        loop();
    }
}

const game = new Solitaire();

document.getElementById('stock').onclick = () => {
    game.saveState();
    if(game.stock.length) {
        let c = game.stock.pop(); c.faceUp = true; game.waste.push(c);
    } else {
        game.stock = game.waste.map(c => ({...c, faceUp: false})).reverse();
        game.waste = [];
    }
    game.render();
};
</script>
</body>
</html>
