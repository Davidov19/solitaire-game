<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solitaire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: 
                radial-gradient(ellipse at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.3) 100%),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px),
                linear-gradient(180deg, #0a4d2e 0%, #0d5c38 50%, #0a4d2e 100%);
            min-height: 100vh;
            padding: 20px;
            user-select: none;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255,255,255,0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0,0,0,0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .container {
            position: relative;
            z-index: 2;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(180deg, #3d2817 0%, #6b4423 50%, #3d2817 100%);
            padding: 20px 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.4);
            border: 2px solid #2a1810;
        }

        .stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 11px;
            color: #d4af37;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 10px rgba(212, 175, 55, 0.3);
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .card-back-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }

        .card-back-selector label {
            font-size: 12px;
            color: #d4af37;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .card-back-selector select {
            padding: 6px 10px;
            border: 2px solid #8b7355;
            border-radius: 6px;
            background: linear-gradient(180deg, #f5f5dc 0%, #d2b48c 100%);
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            color: #3d2817;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(180deg, #2d5016 0%, #1a3a0f 100%);
            color: #fff;
            border: 2px solid #3d6b1f;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 0 rgba(0, 0, 0, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        button:hover {
            background: linear-gradient(180deg, #3a6b1e 0%, #254d13 100%);
            transform: translateY(-2px);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-board {
            padding: 30px 20px;
            border-radius: 15px;
            min-height: 600px;
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 60px;
        }

        .left-section {
            display: flex;
            gap: 20px;
        }

        .foundation-piles {
            display: flex;
            gap: 20px;
        }

        .card-pile {
            width: 80px;
            height: 110px;
            border: 2px dashed rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.15) 0%, rgba(0, 0, 0, 0.25) 100%);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.4),
                0 1px 0 rgba(255, 255, 255, 0.03);
        }

        .card-pile.foundation {
            border-color: rgba(212, 175, 55, 0.2);
            background: radial-gradient(ellipse at center, rgba(212, 175, 55, 0.05) 0%, rgba(0, 0, 0, 0.25) 100%);
        }

        .tableau {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .tableau-pile {
            width: 80px;
            min-height: 110px;
            position: relative;
        }

        .card {
            width: 80px;
            height: 110px;
            background: linear-gradient(180deg, #ffffff 0%, #f8f8f8 100%);
            border: 1px solid #333;
            border-radius: 10px;
            position: absolute;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                0 6px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 10px 25px rgba(0, 0, 0, 0.6),
                0 15px 35px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            z-index: 100;
        }

        .card.red {
            color: #dc143c;
        }

        .card.black {
            color: #000;
        }

        .card.face-down {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            cursor: default;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                0 6px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .card.face-down:hover {
            transform: none;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                0 6px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Tropical Theme */
        .card.face-down.tropical {
            background: linear-gradient(135deg, #06beb6 0%, #48b1bf 100%);
            position: relative;
            overflow: hidden;
        }

        .card.face-down.tropical::before {
            content: 'üå¥';
            position: absolute;
            font-size: 50px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
        }

        .card.face-down.tropical::after {
            content: 'üå∫';
            position: absolute;
            font-size: 24px;
            top: 10px;
            right: 10px;
            opacity: 0.5;
        }

        /* Classic Red Playing Card Theme */
        .card.face-down.classic-red {
            background: linear-gradient(to bottom, #dc143c 0%, #b71c1c 100%);
            border: 3px solid white;
            box-shadow: inset 0 0 0 2px #8b0000, inset 0 0 0 4px white;
            position: relative;
        }

        .card.face-down.classic-red::before {
            content: '';
            position: absolute;
            inset: 10px;
            border: 2px solid white;
            border-radius: 3px;
            background: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px),
                repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px);
        }

        .card.face-down.classic-red::after {
            content: '‚ùñ';
            position: absolute;
            font-size: 50px;
            color: rgba(255, 255, 255, 0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        /* Classic Blue Playing Card Theme */
        .card.face-down.classic-blue {
            background: linear-gradient(to bottom, #1565c0 0%, #0d47a1 100%);
            border: 3px solid white;
            box-shadow: inset 0 0 0 2px #003c8f, inset 0 0 0 4px white;
            position: relative;
        }

        .card.face-down.classic-blue::before {
            content: '';
            position: absolute;
            inset: 10px;
            border: 2px solid white;
            border-radius: 3px;
            background: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px),
                repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px);
        }

        .card.face-down.classic-blue::after {
            content: '‚ùñ';
            position: absolute;
            font-size: 50px;
            color: rgba(255, 255, 255, 0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        /* Space/Sci-Fi Theme */
        .card.face-down.space {
            background: radial-gradient(circle at 30% 40%, #1a0033 0%, #000033 50%, #000000 100%);
            position: relative;
            overflow: hidden;
        }

        .card.face-down.space::before {
            content: '‚≠ê';
            position: absolute;
            font-size: 16px;
            top: 15%;
            left: 20%;
            animation: twinkle 2s infinite;
        }

        .card.face-down.space::after {
            content: 'üåô';
            position: absolute;
            font-size: 30px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.7;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Mjolnir/Thor Theme */
        .card.face-down.mjolnir {
            background: linear-gradient(135deg, #1c1c2e 0%, #2d2d44 50%, #1c1c2e 100%);
            position: relative;
            overflow: hidden;
        }

        .card.face-down.mjolnir::before {
            content: 'üî®';
            position: absolute;
            font-size: 45px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            filter: drop-shadow(0 0 8px #4dabf7) drop-shadow(0 0 12px #4dabf7);
        }

        .card.face-down.mjolnir::after {
            content: '‚ö°';
            position: absolute;
            font-size: 20px;
            color: #ffd700;
            top: 20%;
            right: 20%;
            animation: lightning 1.5s infinite;
        }

        @keyframes lightning {
            0%, 100% { 
                opacity: 0.4;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.2);
                filter: drop-shadow(0 0 5px #ffd700);
            }
        }

        .card-top {
            font-size: 18px;
            font-weight: bold;
        }

        .card-center {
            font-size: 32px;
            text-align: center;
        }

        .card-bottom {
            font-size: 18px;
            font-weight: bold;
            text-align: right;
        }

        .card.dragging {
            opacity: 0.6;
            transform: rotate(3deg) scale(0.95);
        }

        .card.selected {
            box-shadow: 0 0 0 3px #d4af37, 0 10px 25px rgba(0, 0, 0, 0.6);
        }

        .stock-pile {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .stock-pile:hover {
            transform: scale(1.05);
        }

        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #3d2817 0%, #6b4423 50%, #3d2817 100%);
            padding: 50px;
            border-radius: 20px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 3px #2a1810;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 3px solid #d4af37;
        }

        .win-message.show {
            display: block;
            animation: celebration 0.5s ease-out;
        }

        @keyframes celebration {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .win-message h2 {
            color: #d4af37;
            margin-bottom: 25px;
            font-size: 36px;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(212, 175, 55, 0.5);
        }

        .win-message p {
            font-size: 20px;
            margin-bottom: 12px;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .win-message button {
            margin-top: 25px;
        }

        .hint-button {
            background: linear-gradient(180deg, #d4af37 0%, #b8941f 100%);
            border: 2px solid #8b7355;
            color: #2a1810;
        }

        .hint-button:hover {
            background: linear-gradient(180deg, #e6c758 0%, #d4af37 100%);
        }

        .card.hint {
            box-shadow: 
                0 0 0 4px #d4af37,
                0 0 20px rgba(212, 175, 55, 0.8),
                0 10px 25px rgba(0, 0, 0, 0.6);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 
                    0 0 0 4px #d4af37,
                    0 0 20px rgba(212, 175, 55, 0.8),
                    0 10px 25px rgba(0, 0, 0, 0.6);
            }
            50% {
                box-shadow: 
                    0 0 0 6px #d4af37,
                    0 0 30px rgba(212, 175, 55, 1),
                    0 10px 25px rgba(0, 0, 0, 0.6);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">SCORE</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">TIME</div>
                    <div class="stat-value" id="timer">0:00</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">MOVES</div>
                    <div class="stat-value" id="moves">0</div>
                </div>
            </div>
            <div class="controls">
                <div class="card-back-selector">
                    <label for="cardBackSelect">Card Back:</label>
                    <select id="cardBackSelect" onchange="game.changeCardBack(this.value)">
                        <option value="default">Default Blue</option>
                        <option value="classic-red">Classic Red</option>
                        <option value="classic-blue">Classic Blue</option>
                        <option value="tropical">Tropical</option>
                        <option value="space">Space</option>
                        <option value="mjolnir">Mjolnir</option>
                    </select>
                </div>
                <button onclick="game.newGame()" title="Start a completely new game">New Game</button>
                <button onclick="game.restart()" title="Restart the current game">Restart</button>
                <button onclick="game.undo()" title="Undo last move">Undo</button>
                <button class="hint-button" onclick="game.showHint()" title="Show a possible move">Hint</button>
            </div>
        </div>

        <div class="game-board">
            <div class="top-row">
                <div class="left-section">
                    <div class="card-pile stock-pile" id="stock" onclick="game.drawFromStock()"></div>
                    <div class="card-pile" id="waste"></div>
                </div>
                <div class="foundation-piles">
                    <div class="card-pile foundation" id="foundation-0"></div>
                    <div class="card-pile foundation" id="foundation-1"></div>
                    <div class="card-pile foundation" id="foundation-2"></div>
                    <div class="card-pile foundation" id="foundation-3"></div>
                </div>
            </div>

            <div class="tableau">
                <div class="tableau-pile" id="tableau-0"></div>
                <div class="tableau-pile" id="tableau-1"></div>
                <div class="tableau-pile" id="tableau-2"></div>
                <div class="tableau-pile" id="tableau-3"></div>
                <div class="tableau-pile" id="tableau-4"></div>
                <div class="tableau-pile" id="tableau-5"></div>
                <div class="tableau-pile" id="tableau-6"></div>
            </div>
        </div>
    </div>

    <div class="win-message" id="winMessage">
        <h2>üéâ Congratulations! üéâ</h2>
        <p>You won!</p>
        <p id="winScore"></p>
        <p id="winTime"></p>
        <p id="winMoves"></p>
        <button onclick="game.newGame(); document.getElementById('winMessage').classList.remove('show')">New Game</button>
    </div>

    <script>
        const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const RANK_VALUES = {A: 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, J: 11, Q: 12, K: 13};

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.faceUp = false;
                this.id = `${rank}-${suit}`;
            }

            get color() {
                return (this.suit === '‚ô•' || this.suit === '‚ô¶') ? 'red' : 'black';
            }

            get value() {
                return RANK_VALUES[this.rank];
            }
        }

        class SolitaireGame {
            constructor() {
                this.stock = [];
                this.waste = [];
                this.foundation = [[], [], [], []];
                this.tableau = [[], [], [], [], [], [], []];
                this.score = 0;
                this.moves = 0;
                this.seconds = 0;
                this.timer = null;
                this.moveHistory = [];
                this.initialDeck = [];
                this.draggedCards = null;
                this.dragSource = null;
                this.cardBackTheme = 'default';
                
                this.newGame();
            }

            createDeck() {
                const deck = [];
                for (let suit of SUITS) {
                    for (let rank of RANKS) {
                        deck.push(new Card(suit, rank));
                    }
                }
                return this.shuffle(deck);
            }

            shuffle(deck) {
                const shuffled = [...deck];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            newGame() {
                this.stock = [];
                this.waste = [];
                this.foundation = [[], [], [], []];
                this.tableau = [[], [], [], [], [], [], []];
                this.score = 0;
                this.moves = 0;
                this.seconds = 0;
                this.moveHistory = [];

                const deck = this.createDeck();
                this.initialDeck = deck.map(card => ({suit: card.suit, rank: card.rank}));

                let cardIndex = 0;
                for (let i = 0; i < 7; i++) {
                    for (let j = i; j < 7; j++) {
                        const card = deck[cardIndex++];
                        if (j === i) {
                            card.faceUp = true;
                        }
                        this.tableau[j].push(card);
                    }
                }

                this.stock = deck.slice(cardIndex);
                
                this.startTimer();
                this.render();
                this.updateStats();
            }

            restart() {
                this.stock = [];
                this.waste = [];
                this.foundation = [[], [], [], []];
                this.tableau = [[], [], [], [], [], [], []];
                this.score = 0;
                this.moves = 0;
                this.seconds = 0;
                this.moveHistory = [];

                const deck = this.initialDeck.map(cardData => new Card(cardData.suit, cardData.rank));

                let cardIndex = 0;
                for (let i = 0; i < 7; i++) {
                    for (let j = i; j < 7; j++) {
                        const card = deck[cardIndex++];
                        if (j === i) {
                            card.faceUp = true;
                        }
                        this.tableau[j].push(card);
                    }
                }

                this.stock = deck.slice(cardIndex);
                
                this.startTimer();
                this.render();
                this.updateStats();
            }

            startTimer() {
                if (this.timer) clearInterval(this.timer);
                this.timer = setInterval(() => {
                    this.seconds++;
                    this.updateStats();
                }, 1000);
            }

            updateStats() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                
                const minutes = Math.floor(this.seconds / 60);
                const secs = this.seconds % 60;
                document.getElementById('timer').textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
            }

            drawFromStock() {
                if (this.stock.length > 0) {
                    const card = this.stock.pop();
                    card.faceUp = true;
                    this.waste.push(card);
                    this.moveHistory.push({type: 'draw', from: 'stock'});
                    this.score -= 5;
                } else if (this.waste.length > 0) {
                    this.stock = this.waste.reverse();
                    this.waste = [];
                    this.stock.forEach(card => card.faceUp = false);
                    this.moveHistory.push({type: 'reset-stock'});
                }
                
                this.moves++;
                this.render();
                this.updateStats();
            }

            canPlaceOnFoundation(card, foundationIndex) {
                const foundation = this.foundation[foundationIndex];
                if (foundation.length === 0) {
                    return card.rank === 'A';
                }
                const topCard = foundation[foundation.length - 1];
                return card.suit === topCard.suit && card.value === topCard.value + 1;
            }

            canPlaceOnTableau(card, tableauIndex) {
                const tableau = this.tableau[tableauIndex];
                if (tableau.length === 0) {
                    return card.rank === 'K';
                }
                const topCard = tableau[tableau.length - 1];
                return card.color !== topCard.color && card.value === topCard.value - 1;
            }

            moveToFoundation(card, sourceType, sourceIndex) {
                for (let i = 0; i < 4; i++) {
                    if (this.canPlaceOnFoundation(card, i)) {
                        let sourceCards;
                        if (sourceType === 'waste') {
                            sourceCards = this.waste;
                        } else if (sourceType === 'tableau') {
                            sourceCards = this.tableau[sourceIndex];
                        }

                        if (sourceCards && sourceCards[sourceCards.length - 1] === card) {
                            sourceCards.pop();
                            this.foundation[i].push(card);
                            
                            this.moveHistory.push({
                                type: 'move',
                                from: sourceType,
                                fromIndex: sourceIndex,
                                to: 'foundation',
                                toIndex: i,
                                card: {suit: card.suit, rank: card.rank}
                            });

                            if (sourceType === 'tableau' && sourceCards.length > 0) {
                                const newTop = sourceCards[sourceCards.length - 1];
                                if (!newTop.faceUp) {
                                    newTop.faceUp = true;
                                    this.moveHistory[this.moveHistory.length - 1].flipped = true;
                                    this.score += 5;
                                }
                            }

                            this.score += 10;
                            this.moves++;
                            this.checkWin();
                            return true;
                        }
                    }
                }
                return false;
            }

            moveCards(cards, sourceType, sourceIndex, destType, destIndex) {
                let source, dest;
                
                if (sourceType === 'waste') {
                    source = this.waste;
                } else if (sourceType === 'tableau') {
                    source = this.tableau[sourceIndex];
                } else if (sourceType === 'foundation') {
                    source = this.foundation[sourceIndex];
                }

                if (destType === 'tableau') {
                    dest = this.tableau[destIndex];
                } else if (destType === 'foundation') {
                    dest = this.foundation[destIndex];
                }

                if (!source || !dest) return false;

                const cardIndex = source.indexOf(cards[0]);
                if (cardIndex === -1) return false;

                const movedCards = source.splice(cardIndex, cards.length);
                dest.push(...movedCards);

                this.moveHistory.push({
                    type: 'move',
                    from: sourceType,
                    fromIndex: sourceIndex,
                    to: destType,
                    toIndex: destIndex,
                    cards: movedCards.map(c => ({suit: c.suit, rank: c.rank})),
                    count: movedCards.length
                });

                if (source.length > 0 && sourceType === 'tableau') {
                    const newTop = source[source.length - 1];
                    if (!newTop.faceUp) {
                        newTop.faceUp = true;
                        this.moveHistory[this.moveHistory.length - 1].flipped = true;
                        this.score += 5;
                    }
                }

                if (destType === 'foundation') {
                    this.score += 10;
                } else if (sourceType === 'foundation' && destType === 'tableau') {
                    this.score -= 15;
                } else {
                    this.score += 5;
                }

                this.moves++;
                this.checkWin();
                return true;
            }

            undo() {
                if (this.moveHistory.length === 0) return;

                const lastMove = this.moveHistory.pop();

                if (lastMove.type === 'draw') {
                    const card = this.waste.pop();
                    card.faceUp = false;
                    this.stock.push(card);
                    this.score += 5;
                } else if (lastMove.type === 'reset-stock') {
                    this.waste = this.stock.reverse();
                    this.waste.forEach(card => card.faceUp = true);
                    this.stock = [];
                } else if (lastMove.type === 'move') {
                    const from = lastMove.from === 'waste' ? this.waste :
                                lastMove.from === 'tableau' ? this.tableau[lastMove.fromIndex] :
                                this.foundation[lastMove.fromIndex];
                    
                    const to = lastMove.to === 'tableau' ? this.tableau[lastMove.toIndex] :
                              this.foundation[lastMove.toIndex];

                    const count = lastMove.count || 1;
                    const movedCards = to.splice(to.length - count, count);
                    
                    movedCards.forEach(movedCard => {
                        const originalCard = lastMove.cards ? lastMove.cards.find(c => c.suit === movedCard.suit && c.rank === movedCard.rank) : lastMove.card;
                        if (originalCard) {
                            from.push(movedCard);
                        }
                    });

                    if (lastMove.flipped && from.length > 0) {
                        from[from.length - 1].faceUp = false;
                        this.score -= 5;
                    }

                    if (lastMove.to === 'foundation') {
                        this.score -= 10;
                    } else if (lastMove.from === 'foundation' && lastMove.to === 'tableau') {
                        this.score += 15;
                    } else {
                        this.score -= 5;
                    }
                }

                this.moves++;
                this.render();
                this.updateStats();
            }

            showHint() {
                document.querySelectorAll('.card.hint').forEach(card => card.classList.remove('hint'));

                for (let i = 0; i < this.tableau.length; i++) {
                    const pile = this.tableau[i];
                    if (pile.length > 0) {
                        const card = pile[pile.length - 1];
                        if (card.faceUp) {
                            for (let j = 0; j < 4; j++) {
                                if (this.canPlaceOnFoundation(card, j)) {
                                    const element = document.querySelector(`[data-card-id="${card.id}"]`);
                                    if (element) element.classList.add('hint');
                                    setTimeout(() => {
                                        document.querySelectorAll('.card.hint').forEach(c => c.classList.remove('hint'));
                                    }, 2000);
                                    return;
                                }
                            }
                        }
                    }
                }

                for (let i = 0; i < this.tableau.length; i++) {
                    const pile = this.tableau[i];
                    for (let k = 0; k < pile.length; k++) {
                        const card = pile[k];
                        if (card.faceUp) {
                            for (let j = 0; j < this.tableau.length; j++) {
                                if (i !== j && this.canPlaceOnTableau(card, j)) {
                                    const element = document.querySelector(`[data-card-id="${card.id}"]`);
                                    if (element) element.classList.add('hint');
                                    setTimeout(() => {
                                        document.querySelectorAll('.card.hint').forEach(c => c.classList.remove('hint'));
                                    }, 2000);
                                    return;
                                }
                            }
                        }
                    }
                }

                if (this.waste.length > 0) {
                    const card = this.waste[this.waste.length - 1];
                    for (let i = 0; i < this.tableau.length; i++) {
                        if (this.canPlaceOnTableau(card, i)) {
                            const element = document.querySelector(`[data-card-id="${card.id}"]`);
                            if (element) element.classList.add('hint');
                            setTimeout(() => {
                                document.querySelectorAll('.card.hint').forEach(c => c.classList.remove('hint'));
                            }, 2000);
                            return;
                        }
                    }
                }
            }

            checkWin() {
                const totalInFoundation = this.foundation.reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundation === 52) {
                    clearInterval(this.timer);
                    this.score += 500;
                    this.updateStats();
                    
                    setTimeout(() => {
                        const winMsg = document.getElementById('winMessage');
                        document.getElementById('winScore').textContent = `Score: ${this.score}`;
                        document.getElementById('winTime').textContent = `Time: ${document.getElementById('timer').textContent}`;
                        document.getElementById('winMoves').textContent = `Moves: ${this.moves}`;
                        winMsg.classList.add('show');
                    }, 500);
                }
            }

            changeCardBack(theme) {
                this.cardBackTheme = theme;
                this.render();
            }

            render() {
                document.getElementById('stock').innerHTML = '';
                if (this.stock.length > 0) {
                    const stockCard = this.createCardElement(this.stock[this.stock.length - 1], false);
                    stockCard.style.position = 'absolute';
                    stockCard.style.top = '0';
                    stockCard.style.left = '0';
                    stockCard.style.cursor = 'pointer';
                    document.getElementById('stock').appendChild(stockCard);
                }

                document.getElementById('waste').innerHTML = '';
                if (this.waste.length > 0) {
                    const wasteCard = this.createCardElement(this.waste[this.waste.length - 1], true);
                    wasteCard.style.position = 'absolute';
                    wasteCard.style.top = '0';
                    wasteCard.style.left = '0';
                    wasteCard.dataset.source = 'waste';
                    this.addCardInteraction(wasteCard, this.waste[this.waste.length - 1], 'waste', 0);
                    document.getElementById('waste').appendChild(wasteCard);
                }

                for (let i = 0; i < 4; i++) {
                    const foundationEl = document.getElementById(`foundation-${i}`);
                    foundationEl.innerHTML = '';
                    if (this.foundation[i].length > 0) {
                        const card = this.foundation[i][this.foundation[i].length - 1];
                        const cardEl = this.createCardElement(card, true);
                        cardEl.style.position = 'absolute';
                        cardEl.style.top = '0';
                        cardEl.style.left = '0';
                        cardEl.dataset.source = 'foundation';
                        cardEl.dataset.index = i;
                        this.addCardInteraction(cardEl, card, 'foundation', i);
                        foundationEl.appendChild(cardEl);
                    }
                    this.addDropZone(foundationEl, 'foundation', i);
                }

                for (let i = 0; i < 7; i++) {
                    const tableauEl = document.getElementById(`tableau-${i}`);
                    tableauEl.innerHTML = '';
                    
                    this.tableau[i].forEach((card, index) => {
                        const cardEl = this.createCardElement(card, card.faceUp);
                        cardEl.style.position = 'absolute';
                        cardEl.style.top = `${index * 25}px`;
                        cardEl.style.left = '0';
                        cardEl.dataset.source = 'tableau';
                        cardEl.dataset.index = i;
                        cardEl.dataset.cardIndex = index;
                        
                        if (card.faceUp) {
                            this.addCardInteraction(cardEl, card, 'tableau', i);
                        }
                        
                        tableauEl.appendChild(cardEl);
                    });

                    this.addDropZone(tableauEl, 'tableau', i);
                }
            }

            createCardElement(card, faceUp) {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.color}`;
                cardEl.dataset.cardId = card.id;
                
                if (!faceUp) {
                    cardEl.classList.add('face-down');
                    if (this.cardBackTheme !== 'default') {
                        cardEl.classList.add(this.cardBackTheme);
                    }
                } else {
                    cardEl.innerHTML = `
                        <div class="card-top">${card.rank}${card.suit}</div>
                        <div class="card-center">${card.suit}</div>
                        <div class="card-bottom">${card.rank}${card.suit}</div>
                    `;
                }
                
                return cardEl;
            }

            addCardInteraction(cardEl, card, sourceType, sourceIndex) {
                cardEl.draggable = true;
                
                cardEl.addEventListener('dragstart', (e) => {
                    const cardIndex = parseInt(cardEl.dataset.cardIndex) || 0;
                    
                    if (sourceType === 'tableau') {
                        const pile = this.tableau[sourceIndex];
                        this.draggedCards = pile.slice(cardIndex);
                    } else {
                        this.draggedCards = [card];
                    }
                    
                    this.dragSource = {type: sourceType, index: sourceIndex};
                    cardEl.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                cardEl.addEventListener('dragend', () => {
                    cardEl.classList.remove('dragging');
                    this.draggedCards = null;
                    this.dragSource = null;
                });

                cardEl.addEventListener('dblclick', () => {
                    this.moveToFoundation(card, sourceType, sourceIndex);
                    this.render();
                    this.updateStats();
                });
            }

            addDropZone(element, destType, destIndex) {
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });

                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    if (!this.draggedCards || !this.dragSource) return;

                    const firstCard = this.draggedCards[0];
                    let canDrop = false;

                    if (destType === 'foundation' && this.draggedCards.length === 1) {
                        canDrop = this.canPlaceOnFoundation(firstCard, destIndex);
                    } else if (destType === 'tableau') {
                        if (this.tableau[destIndex].length === 0) {
                            canDrop = firstCard.rank === 'K';
                        } else {
                            canDrop = this.canPlaceOnTableau(firstCard, destIndex);
                        }
                    }

                    if (canDrop) {
                        this.moveCards(
                            this.draggedCards,
                            this.dragSource.type,
                            this.dragSource.index,
                            destType,
                            destIndex
                        );
                        this.render();
                        this.updateStats();
                    }
                });
            }
        }

        const game = new SolitaireGame();
    </script>
</body>
</html>
