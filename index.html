<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Instant Touch Solitaire</title>
    <style>
        :root {
            --green: #1a5e20;
            --card-w: calc((100vw - 50px) / 7);
            --card-h: calc(var(--card-w) * 1.4);
            --gap: 5px;
        }
        body {
            background-color: var(--green);
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Prevents browser pull-to-refresh and zoom */
            user-select: none;
        }
        #hud {
            background: rgba(0,0,0,0.8);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 10px;
            font-size: 0.8rem;
            color: white;
            text-align: center;
        }
        .btn {
            background: #fff; border: none; padding: 4px 8px;
            border-radius: 4px; font-weight: bold; color: var(--green);
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: var(--gap);
            padding: 10px 5px;
            max-width: 800px;
            margin: 0 auto;
        }
        .pile {
            width: var(--card-w);
            height: var(--card-h);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            position: relative;
        }
        .card {
            width: var(--card-w);
            height: var(--card-h);
            background: white;
            border-radius: 4px;
            position: absolute;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            color: black;
            padding: 3px;
            box-sizing: border-box;
            font-size: 0.7rem;
            pointer-events: none; /* Let the pile handle the touch */
            border: 0.5px solid #ccc;
        }
        .card.back {
            background: #2b5797;
            background-image: repeating-linear-gradient(135deg, #2b5797, #2b5797 4px, #3b67a7 4px, #3b67a7 8px);
            border: 1.5px solid white;
        }
        .card.red { color: #d32f2f; }
        .suit-center {
            font-size: 1.2rem; text-align: center; flex-grow: 1;
            display: flex; align-items: center; justify-content: center;
        }
        .tableau-stack { grid-row: 2; margin-top: 10px; }
        
        /* Floating effect during drag */
        .dragging-active {
            z-index: 10000 !important;
            opacity: 0.9;
            transform: scale(1.1);
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="hud">
    <div><button class="btn" onclick="game.initGame()">New</button></div>
    <div>Score: <span id="score">0</span></div>
    <div><button class="btn" onclick="game.undo()">Undo</button></div>
</div>

<div id="game-board">
    <div id="stock" class="pile"></div>
    <div id="waste" class="pile"></div>
    <div class="spacer"></div>
    <div class="pile foundation" data-idx="0"></div>
    <div class="pile foundation" data-idx="1"></div>
    <div class="pile foundation" data-idx="2"></div>
    <div class="pile foundation" data-idx="3"></div>

    <div class="pile tableau-stack" data-idx="0"></div>
    <div class="pile tableau-stack" data-idx="1"></div>
    <div class="pile tableau-stack" data-idx="2"></div>
    <div class="pile tableau-stack" data-idx="3"></div>
    <div class="pile tableau-stack" data-idx="4"></div>
    <div class="pile tableau-stack" data-idx="5"></div>
    <div class="pile tableau-stack" data-idx="6"></div>
</div>

<script>
const SUITS = ['♠', '♣', '♥', '♦'];
const VALS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

class Solitaire {
    constructor() {
        this.history = [];
        this.dragElement = null;
        this.lastTap = 0;
        this.initGame();
        this.setupTouchListeners();
    }

    initGame() {
        this.score = 0;
        this.history = [];
        let deck = [];
        SUITS.forEach(s => VALS.forEach((v, i) => {
            deck.push({ suit: s, val: v, rank: i+1, color: (s==='♥'||s==='♦')?'red':'black', faceUp: false });
        }));
        deck.sort(() => Math.random() - 0.5);

        this.foundations = [[],[],[],[]];
        this.tableau = [[],[],[],[],[],[],[]];
        for(let i=0; i<7; i++) {
            for(let j=i; j<7; j++) {
                let card = deck.pop();
                if(i === j) card.faceUp = true;
                this.tableau[j].push(card);
            }
        }
        this.stock = deck;
        this.waste = [];
        this.render();
    }

    render() {
        document.getElementById('score').innerText = this.score;
        this.drawPile('#stock', this.stock, 'stock');
        this.drawPile('#waste', this.waste, 'waste');
        this.foundations.forEach((f, i) => this.drawPile(`.foundation[data-idx="${i}"]`, f, 'foundation', i));
        this.tableau.forEach((t, i) => this.drawPile(`.tableau-stack[data-idx="${i}"]`, t, 'tableau', i));
    }

    drawPile(sel, cards, type, pIdx) {
        const el = document.querySelector(sel);
        el.innerHTML = '';
        el.dataset.type = type;
        el.dataset.pIdx = pIdx;

        cards.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = `card ${c.faceUp ? c.color : 'back'}`;
            div.dataset.index = i;
            if(c.faceUp) {
                div.innerHTML = `<div>${c.val}${c.suit}</div><div class="suit-center">${c.suit}</div>`;
            }
            if(type === 'tableau') div.style.top = `${i * 18}px`;
            el.appendChild(div);
        });
    }

    setupTouchListeners() {
        document.addEventListener('touchstart', (e) => {
            const pile = e.target.closest('.pile');
            if (!pile) return;

            const type = pile.dataset.type;
            const pIdx = parseInt(pile.dataset.pIdx);
            const cards = this.getCardsFromType(type, pIdx);
            if (!cards || cards.length === 0 && type !== 'stock') return;

            // Handle Stock Click
            if (type === 'stock') {
                this.handleStock();
                return;
            }

            // Find clicked card index
            const cardEl = e.target.closest('.card');
            if (!cardEl) return;
            const cIdx = parseInt(cardEl.dataset.index);
            const card = cards[cIdx];

            if (!card || !card.faceUp) return;

            // Double Tap Check
            const now = Date.now();
            if (now - this.lastTap < 300) {
                this.autoMove(card, type, pIdx);
                this.lastTap = 0;
                return;
            }
            this.lastTap = now;

            // Start Drag
            this.dragging = type === 'tableau' ? cards.slice(cIdx) : [card];
            this.source = { type, pIdx };
            
            // Visual Ghost
            this.dragElement = cardEl.cloneNode(true);
            this.dragElement.classList.add('dragging-active');
            document.body.appendChild(this.dragElement);
            this.moveGhost(e.touches[0]);
        });

        document.addEventListener('touchmove', (e) => {
            if (this.dragElement) {
                e.preventDefault();
                this.moveGhost(e.touches[0]);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (!this.dragElement) return;
            
            const touch = e.changedTouches[0];
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.pile');
            
            if (dropTarget) {
                this.handleDrop(dropTarget.dataset.type, parseInt(dropTarget.dataset.pIdx));
            }

            document.body.removeChild(this.dragElement);
            this.dragElement = null;
            this.dragging = null;
        });
    }

    moveGhost(touch) {
        this.dragElement.style.left = `${touch.clientX - 40}px`;
        this.dragElement.style.top = `${touch.clientY - 20}px`;
        this.dragElement.style.position = 'fixed';
    }

    getCardsFromType(type, idx) {
        if (type === 'stock') return this.stock;
        if (type === 'waste') return this.waste;
        if (type === 'foundation') return this.foundations[idx];
        if (type === 'tableau') return this.tableau[idx];
    }

    handleStock() {
        this.saveState();
        if(this.stock.length) {
            let c = this.stock.pop(); c.faceUp = true; this.waste.push(c);
        } else {
            this.stock = this.waste.map(c => ({...c, faceUp: false})).reverse();
            this.waste = [];
        }
        this.render();
    }

    handleDrop(type, pIdx) {
        const c = this.dragging[0];
        let ok = false;
        if (type === 'foundation' && this.dragging.length === 1) {
            const f = this.foundations[pIdx];
            ok = f.length === 0 ? c.rank === 1 : (c.suit === f[f.length-1].suit && c.rank === f[f.length-1].rank + 1);
        } else if (type === 'tableau') {
            const t = this.tableau[pIdx];
            ok = t.length === 0 ? c.rank === 13 : (c.color !== t[t.length-1].color && c.rank === t[t.length-1].rank - 1);
        }

        if (ok) {
            this.saveState();
            const src = this.getCardsFromType(this.source.type, this.source.pIdx);
            const moved = src.splice(src.length - this.dragging.length);
            this.getCardsFromType(type, pIdx).push(...moved);
            if (src.length > 0 && !src[src.length-1].faceUp) { src[src.length-1].faceUp = true; this.score += 5; }
            this.score += (type === 'foundation' ? 10 : 5);
            this.render();
        }
    }

    autoMove(c, type, pIdx) {
        // Check Foundations first
        for(let i=0; i<4; i++) {
            const f = this.foundations[i];
            if((f.length===0 && c.rank===1) || (f.length>0 && c.suit===f[f.length-1].suit && c.rank===f[f.length-1].rank+1)) {
                this.dragging = [c]; this.source = {type, pIdx};
                this.handleDrop('foundation', i);
                return;
            }
        }
        // Then check Tableau
        for(let i=0; i<7; i++) {
            const t = this.tableau[i];
            if((t.length===0 && c.rank===13) || (t.length>0 && c.color!==t[t.length-1].color && c.rank===t[t.length-1].rank-1)) {
                this.dragging = [c]; this.source = {type, pIdx};
                this.handleDrop('tableau', i);
                return;
            }
        }
    }

    saveState() {
        this.history.push(JSON.stringify({stock:this.stock, waste:this.waste, foundations:this.foundations, tableau:this.tableau, score:this.score}));
    }

    undo() {
        if (!this.history.length) return;
        const s = JSON.parse(this.history.pop());
        this.stock=s.stock; this.waste=s.waste; this.foundations=s.foundations; this.tableau=s.tableau; this.score=s.score;
        this.render();
    }
}

const game = new Solitaire();
</script>
</body>
</html>
