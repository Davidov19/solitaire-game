<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Solitaire</title>
    <style>
        :root {
            --green: #1a5e20;
            --card-width: clamp(50px, 11vw, 90px);
            --card-height: calc(var(--card-width) * 1.45);
            --radius: 6px;
        }
        body {
            background-color: var(--green);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
            color: white;
            user-select: none;
        }
        /* Top Navigation Bar */
        #hud {
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .btn {
            background: #fff;
            color: #1a5e20;
            border: none;
            padding: 6px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }

        #game-board {
            position: relative;
            width: 100vw;
            height: calc(100vh - 50px);
            padding-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .row { display: flex; justify-content: center; gap: 15px; width: 95%; max-width: 900px; margin-bottom: 20px; }

        .pile {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: var(--radius);
            position: relative;
        }

        /* Card Styling */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border-radius: var(--radius);
            position: absolute;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            color: black;
            padding: 6px;
            box-sizing: border-box;
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            transition: top 0.2s ease;
        }
        .card.red { color: #d32f2f; }
        .card.back {
            background: #1e88e5;
            background-image: repeating-linear-gradient(135deg, #1565c0, #1565c0 10px, #1e88e5 10px, #1e88e5 20px);
            border: 3px solid white;
        }
        .card-suit-big {
            align-self: center;
            font-size: 2rem;
            margin-top: 5px;
        }

        /* Animation Canvas */
        #victory-canvas {
            position: fixed;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
</head>
<body>

    <div id="hud">
        <button class="btn" onclick="game.initGame()">New Game</button>
        <div>Score: <span id="score">0</span></div>
        <div>Time: <span id="timer">0:00</span></div>
        <button class="btn" onclick="location.reload()">Restart</button>
    </div>

    <div id="game-board">
        <div class="row">
            <div id="stock" class="pile"></div>
            <div id="waste" class="pile"></div>
            <div style="width: 20px;"></div> <div class="pile foundation" data-idx="0"></div>
            <div class="pile foundation" data-idx="1"></div>
            <div class="pile foundation" data-idx="2"></div>
            <div class="pile foundation" data-idx="3"></div>
        </div>
        <div class="row">
            <div class="pile tableau" data-idx="0"></div>
            <div class="pile tableau" data-idx="1"></div>
            <div class="pile tableau" data-idx="2"></div>
            <div class="pile tableau" data-idx="3"></div>
            <div class="pile tableau" data-idx="4"></div>
            <div class="pile tableau" data-idx="5"></div>
            <div class="pile tableau" data-idx="6"></div>
        </div>
    </div>

    <canvas id="victory-canvas"></canvas>

<script>
const SUITS = ['♠', '♣', '♥', '♦'];
const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

class SolitaireGame {
    constructor() {
        this.canvas = document.getElementById('victory-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.score = 0;
        this.seconds = 0;
        this.timerInterval = null;
        this.initGame();
    }

    initGame() {
        clearInterval(this.timerInterval);
        this.seconds = 0;
        this.score = 0;
        this.updateHUD();
        this.timerInterval = setInterval(() => {
            this.seconds++;
            document.getElementById('timer').innerText = 
                Math.floor(this.seconds / 60) + ":" + (this.seconds % 60).toString().padStart(2, '0');
        }, 1000);

        const deck = [];
        SUITS.forEach(suit => {
            VALUES.forEach((val, i) => {
                deck.push({ suit, value: val, rank: i + 1, color: (suit === '♥' || suit === '♦') ? 'red' : 'black', faceUp: false });
            });
        });
        
        // Fisher-Yates Shuffle
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        this.stock = deck;
        this.waste = [];
        this.foundations = [[], [], [], []];
        this.tableau = Array.from({length: 7}, () => []);
        
        for (let i = 0; i < 7; i++) {
            for (let j = i; j < 7; j++) {
                const card = this.stock.pop();
                if (i === j) card.faceUp = true;
                this.tableau[j].push(card);
            }
        }
        this.render();
    }

    updateHUD() {
        document.getElementById('score').innerText = this.score;
    }

    render() {
        this.renderPile('stock', this.stock, 'stock');
        this.renderPile('waste', this.waste, 'waste');
        this.foundations.forEach((f, i) => this.renderPile(`.foundation[data-idx="${i}"]`, f, 'foundation', i));
        this.tableau.forEach((t, i) => this.renderPile(`.tableau[data-idx="${i}"]`, t, 'tableau', i));
    }

    renderPile(selector, cards, type, pileIdx) {
        const container = document.querySelector(selector);
        container.innerHTML = '';
        
        cards.forEach((card, i) => {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.faceUp ? card.color : 'back'}`;
            if (card.faceUp) {
                cardEl.innerHTML = `<span>${card.value}${card.suit}</span><span class="card-suit-big">${card.suit}</span>`;
                this.addDragEvents(cardEl, card, type, pileIdx, i);
                cardEl.ondblclick = () => this.autoMove(card, type, pileIdx);
            }
            if (type === 'tableau') cardEl.style.top = `${i * 25}px`;
            container.appendChild(cardEl);
        });

        container.ondragover = (e) => e.preventDefault();
        container.ondrop = (e) => this.handleDrop(type, pileIdx);
    }

    addDragEvents(el, card, type, pIdx, cIdx) {
        el.draggable = true;
        el.ondragstart = () => {
            this.draggedCards = type === 'tableau' ? this.tableau[pIdx].slice(cIdx) : [card];
            this.dragSource = { type, index: pIdx };
        };
    }

    handleDrop(destType, destIdx) {
        if (!this.draggedCards) return;
        const card = this.draggedCards[0];
        let valid = false;

        if (destType === 'foundation' && this.draggedCards.length === 1) {
            const f = this.foundations[destIdx];
            valid = f.length === 0 ? card.rank === 1 : (card.suit === f[f.length-1].suit && card.rank === f[f.length-1].rank + 1);
            if (valid) this.score += 10;
        } else if (destType === 'tableau') {
            const t = this.tableau[destIdx];
            valid = t.length === 0 ? card.rank === 13 : (card.color !== t[t.length-1].color && card.rank === t[t.length-1].rank - 1);
            if (valid && this.dragSource.type === 'waste') this.score += 5;
        }

        if (valid) {
            const src = this.dragSource.type === 'tableau' ? this.tableau[this.dragSource.index] : this.waste;
            const moved = src.splice(src.length - this.draggedCards.length);
            (destType === 'tableau' ? this.tableau[destIdx] : this.foundations[destIdx]).push(...moved);
            if (src.length > 0 && !src[src.length-1].faceUp) {
                src[src.length-1].faceUp = true;
                this.score += 5;
            }
            this.render();
            this.checkWin();
        }
    }

    autoMove(card, type, pIdx) {
        for (let i = 0; i < 4; i++) {
            const f = this.foundations[i];
            const valid = f.length === 0 ? card.rank === 1 : (card.suit === f[f.length-1].suit && card.rank === f[f.length-1].rank + 1);
            if (valid) {
                this.draggedCards = [card];
                this.dragSource = { type, index: pIdx };
                this.handleDrop('foundation', i);
                break;
            }
        }
    }

    checkWin() {
        if (this.foundations.every(f => f.length === 13)) {
            this.winAnimation();
        }
    }

    winAnimation() {
        clearInterval(this.timerInterval);
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        const cards = [];
        this.foundations.flat().forEach(c => cards.push({...c, x: Math.random()*800, y: 100, vx: (Math.random()-0.5)*10, vy: 2}));

        const animate = () => {
            this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
            cards.forEach(c => {
                c.x += c.vx; c.y += c.vy; c.vy += 0.5;
                if (c.y > this.canvas.height - 100) { c.y = this.canvas.height - 100; c.vy *= -0.8; }
                if (c.x < 0 || c.x > this.canvas.width) c.vx *= -1;
                
                this.ctx.fillStyle = "white";
                this.ctx.fillRect(c.x, c.y, 80, 110);
                this.ctx.fillStyle = c.color;
                this.ctx.fillText(c.value + c.suit, c.x + 5, c.y + 20);
            });
            requestAnimationFrame(animate);
        };
        animate();
    }
}

const game = new SolitaireGame();

document.getElementById('stock').onclick = () => {
    if (game.stock.length) {
        const c = game.stock.pop(); c.faceUp = true;
        game.waste.push(c);
    } else {
        game.stock = game.waste.map(c => ({...c, faceUp: false})).reverse();
        game.waste = [];
    }
    game.render();
};
</script>
</body>
</html>
